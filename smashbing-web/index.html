<html>
  <head>
    <meta content="text/html;charset=utf-8" http-equiv="Content-Type" />
    <title>Ballistic Smashbing!</title>
    <style>
      #container {
        margin: auto;
        max-width: 512px;
      }
    </style>
  </head>

  <body>
    <div id="container">
      <!-- This Canvas is where the game is drawn. -->
      <canvas width="64" height="64" id="game"></canvas>
    </div>
    <!-- This script is generated by `wasm-bindgen` -->
    <script src="smashbing_web.js"></script>
    <!-- This script uses the WebAudio API to implement sound effects. -->
    <script src="audioplayer.js"></script>
    <script>
      delete WebAssembly.instantiateStreaming;
      const CANVAS_OPTS = {
        antialias: false
      };

      // TODO: Maximize the canvas in width or height, as appropriate.
      const CANVAS_SIZE = 64.0; // Set canvas's internal coordinates
      const CANVAS_STYLE_SIZE = 512.0; // Set canvas size on page
      const CANVAS_SCALE = CANVAS_SIZE / CANVAS_STYLE_SIZE;

      let gameCanvas = document.getElementById("game");
      gameCanvas.setAttribute(
        "style",
        `width: ${CANVAS_STYLE_SIZE}px; height: ${CANVAS_STYLE_SIZE}px;`
      );
      let ctx = gameCanvas.getContext("2d", CANVAS_OPTS);
      var game;

      // Attach the game canvas's `onclick` event to a method on the game
      // object that passes a command on to `libsmashbing`.
      gameCanvas.onclick = function(evt) {
        let x = (evt.clientX - gameCanvas.offsetLeft) * CANVAS_SCALE;
        let y = (evt.clientY - gameCanvas.offsetTop) * CANVAS_SCALE;
        console.log("onclick @ %f %f", x, y);
        game.fire_at(x, y);
      };

      // This function is imported into the Rust library and usesd to draw the
      // game.
      function draw_rect(x, y, w, h, c) {
        ctx.fillStyle = c;
        ctx.fillRect(x, y, w, h);
      }

      function exit() {
        // The game needs to do something when exiting (because that command)
        // needs to be handled), but we can't close the window from JavaScript,
        // so just remove the canvas.
      }

      // This sets up the audio player and loads sound effects.
      let player = new AudioPlayer();
      player.addAudio("bounce", "./sounds/bounce.wav");
      player.addAudio("bounce_charge", "./sounds/bounce-charge.wav");
      player.addAudio("impulse", "./sounds/impulse.wav");
      player.addAudio("impulse_exhaust", "./sounds/impulse-exhaust.wav");
      player.addAudio("break1", "./sounds/break1.wav");
      player.addAudio("break2", "./sounds/break2.wav");
      player.addAudio("break3", "./sounds/break3.wav");
      player.addAudio("break4", "./sounds/break4.wav");
      player.addAudio("win", "./sounds/win.wav");

      // This function is imported into the Rust code and lets it control the
      // audio player without having to import its whole API (and handle the
      // fuss of its more complicated methods).
      function play_sound(soundKey) {
        player.playSound(soundKey);
      }

      // Expose the game API struct defined in `lib.rs`.
      const { EmbeddedGame } = wasm_bindgen;

      const DELTA_TIME = 1.0 / 60.0;

      // This sets up the main game loop.
      function run() {
        game = new EmbeddedGame();
        // Note that `game.update` take a time delta in seconds but setInterval
        // expects it to be in milliseconds, so we're doing some unit conversion.
        setInterval(function() {
          game.update(DELTA_TIME);
        }, DELTA_TIME * 1000);
      }

      // Load the WASM module, then start the game loop or log errors as needed.
      wasm_bindgen("./smashbing_web_bg.wasm")
        .then(run)
        .catch(console.error);
    </script>
  </body>
</html>
